import { normalizeInput } from "./input.js"
import { normalizeMetadata } from "./metadata.js"
import { loadFiles, contentLength } from "./zip.js"

function normalizeArgs(file) {
  return file instanceof File || file instanceof Response
    ? [[file], [file]]
    : [[file.input, file.name, file.size], [file.input, file.lastModified]];
}

function* mapMeta(files) {
  for (const file of files) {
    yield normalizeMetadata(...normalizeArgs(file)[0]);
  }
}

async function* mapFiles(files) {
  for await (const file of files) {
    const [metaArgs, dataArgs] = normalizeArgs(file);
    yield Object.assign(normalizeInput(...dataArgs), normalizeMetadata(...metaArgs));
  }
}

/** Given an iterable of file metadata (or equivalent),
 * @returns the exact byte length of the Zip file that would be generated by `downloadZip`. */
export const predictLength = (files) => contentLength(mapMeta(files));

export function downloadZip(files, options) {
  const headers = {
    "Content-Type": "application/zip",
    "Content-Disposition": "attachment",
  };

  if (
    (typeof options.length === "bigint" || Number.isInteger(options.length))
    && options.length > 0
  ) {
    headers["Content-Length"] = String(options.length);
  }

  if (options.metadata) {
    headers["Content-Length"] = String(predictLength(options.metadata));
  }

  return new Response(makeZip(files), { headers })
}

export function makeZip(files) {
  return ReadableFromIter(loadFiles(mapFiles(files)));
}
